void BlockMatrix::gmres(vec &bvec, vec &xvec, int m, double &tol, int &maxIt, Preconditioner &pc)
{
//     double *b  = bvec.memptr();
//     double *x  = xvec.memptr();
//     double *v  = new double[n*(m+1)];
//     double *h  = new double[m*(m+1)/2];
//     double *r  = new double[n];
//     double *y  = new double[m+1];
//     double *c  = new double[m];
//     double *s  = new double[m];
// 
//     double beta, hnew, rd, dd, nrm2b;
//     int i=0, j, uki, u0i;
// 
//     copy(b,b+n,r);
//     pc.solve(r,fpar);
//     nrm2b=(dotprod)
//     ? sqrt(dotprod(r,r,fpar))
//     : cdnrm2(n,r,1);
// 
//     if (maxit%m>0)
//     maxit=(maxit/m+1)*m;
// 
//     for (j=0; j<maxit/m; j++) {
//     copy(x,x+n,r);
//     matvec(r,fpar);
//     cdaxpy(n,-1.,b,1,r,1);
//     psolve(r,fpar);
//     beta=(dotprod)
//       ? sqrt(dotprod(r,r,fpar))
//       : cdnrm2(n,r,1);
//     cdcopy(n,r,1,v,1);
//     cdscal(n,1./beta,v,1);
// 
//     y[0]=beta;
//     uki=0;
//     for (i=0; i<m; i++) {
//       if (std::abs(y[i])<tol*nrm2b)
//         break;
// 
//       double *vi=v+n*i;
//       double *vi1=v+n*(i+1);
//       u0i=uki;
//       copy(vi,vi1,vi1);
//       matvec(vi1,fpar);
//       psolve(vi1,fpar);
//       if (dotprod)
//         for (int k=0; k<i+1; k++)
//           (h+u0i)[k] = dotprod(v+n*k,vi1,fpar);
//       else
//         cdgemv('T',n,i+1,1.,v,n,vi1,1,0.,h+u0i,1);
//       cdgemv('N',n,i+1,-1.,v,n,h+u0i,1,1.,vi1,1);
//       hnew=(dotprod)
//         ? sqrt(dotprod(vi1,vi1,fpar))
//         : cdnrm2(n,vi1,1);
//       cdscal(n,1./hnew,vi1,1);
//       for ( int k=0; k<i; ++k ) {
//         double tmp = c[k]*h[uki]-s[k]*h[uki+1];
//         h[uki+1]   = s[k]*h[uki]+c[k]*h[uki+1];
//         h[uki]     = tmp;
//         ++uki;
//       }
// 
//       rd     = h[uki];
//       dd     = sqrt(rd*rd+hnew*hnew);
//       c[i]   = rd/dd;
//       s[i]   = -hnew/dd;
//       h[uki] = dd;
//       ++uki;
// 
//       y[i+1] = s[i]*y[i];
//       y[i]   = c[i]*y[i];
//     }
// 
//     cdtpsv('U','N','N',i,h,y,1);
//     cdgemv('N',n,i,-1.,v,n,y,1,1.,x,1);
// 
//     if ( std::abs(y[i])<tol*nrm2b )
//       break;
//     }
//     maxit = m*j+i;
//     tol=std::abs(y[i])/nrm2b;
// 
//     delete[] v;
//     delete[] h;
//     delete[] r;
//     delete[] y;
//     delete[] c;
//     delete[] s;
// 
//     return 0;
}
